<<<<<<< HEAD
# Домашние задания по Kotlin

Этот репозиторий содержит домашние задания курса Kotlin для студентов ВШЭ и ИТМО.

## Процесс сдачи

1. Вы работаете над заданием в собственном форке этого репозитория.
2. По окончанию работы вы посылаете Pull Request с изменениями в этот репозиторий.
  - Формат названия пулл-реквеста: `Kotlin. ДЗ <номер задания>, <фамилия и имя сдающего>`
3. Преподаватель проверяет ваше решение и, возможно, оставляет замечения, которые вам необходимо исправить, а также оповещает вас об окончании проверки комментарием в пулл-реквесте.
4. После исправления всех замечаний вы оставляете комментарий в пулл-реквесте; далее либо повторяется пункт 3, либо, при отсутствии замечаний, решение засчитывается и выставляется оценка.
  - Решение не засчитывается если есть хотя бы одно неисправленное замечание

## Сроки сдачи

- Решение со всеми исправленными замечаниями: 1 неделя после дедлайна

## Что оценивается

- Соблюдение [общепринятых соглашений о форматировании кода](https://kotlinlang.org/docs/reference/coding-conventions.html)
- Отсутствие самоповторения
- Покрытие тестами (для заданий в которых необходимо самому придумать тесты)
- Читаемость кода

## Как сдавать домашние задания (в первый раз)

1. Сделайте форк этого репозитория. В дальнейшем вы будете работать с ним.
2. Склонируйте форк к себе на компьютер

  ```
  $ git clone <your-fork-url>
  ```
 
3. Выберите задание над которым вы собираетесь работать:

  ```
  $ git checkout <your-assignment-branch>
  ```

4. Сделайте задание. Обыкновенно от вас будет требоваться реализовать определенный интерфейс и, возможно, написать несколько тестов для него. Подробнее смотрите в README.mkdn в ветке задания.
5. Сохраните изменения и отправьте их на сервер:

  ```
  $ git commit -m <your-message>
  $ git push
  ```
Если вы посылаете ветку в первый раз, необходимо явно указать, что отправление идёт в ваш репозиторий:

  ```
  $ git push -u origin <your-assignment-branch>
  ```

6. Сделайте Pull Request в этот репозиторий. Проверьте, чтобы ветка в репозитории в которую вы делаете реквест совпадала с веткой задания над которым вы работали. О том, как сделать реквест написано [здесь](https://help.github.com/articles/creating-a-pull-request/).
7. При наличии падающих тестов или замечаний с нашей стороны повторите шаги 4 и 5, новый реквест делать не надо.

## Как сдавать домашние задания (в последующие разы)

1. У вас уже должен быть форк и клон форка на комьютере. Если нет, то воспользуйтесь инструкцией выше.
2. Проверьте, что git настроен на синхронизацию с этим репозиторием:

  ```
  $ git remote -v
  ```
  
  Если вывод этой команды содержит `upstream https://github.com/zarechenskiy/kotlin-course-se19`, то перейдите на шаг 4.
3. Настройте git на синхронизацию с этим репозиторием:

  ```
  $ git remote add upstream https://github.com/zarechenskiy/kotlin-course-se19
  ```
4. Обновите свой форк:

  ```
  $ git fetch upstream
  ```
5. Выполните шаги 3-7 из инструкции выше.
=======
# ДЗ02 - Fun programming language

**Дедлайн**: 26.09.2018 23:59 (полный балл), 03.10.2018 23:59 (50%)

Необходимо реализовать интерпретатор простого языка программирования.

## Синтаксис
```
FILE = BLOCK
BLOCK = (STATEMENT)*
BLOCK_WITH_BRACES = "{" BLOCK "}"
STATEMENT = FUNCTION | VARIABLE | EXPRESSION | WHILE | IF | ASSIGNMENT | RETURN
FUNCTION = "fun" IDENTIFIER "(" PARAMETER_NAMES ")" BLOCK_WITH_BRACES
VARIABLE = "var" IDENTIFIER ("=" EXPRESSION)?
PARAMETER_NAMES = IDENTIFIER{,}
WHILE = "while" "(" EXPRESSION ")" BLOCK_WITH_BRACES
IF = "if" "(" EXPRESSION ")" BLOCK_WITH_BRACES ("else" BLOCK_WITH_BRACES)?
ASSIGNMENT = IDENTIFIER "=" EXPRESSION
RETURN = "return" EXPRESSION
EXPRESSION = FUNCTION_CALL | BINARY_EXPRESSION | IDENTIFIER | LITERAL | "(" EXPRESSION ")"
FUNCTION_CALL = IDENTIFIER "(" ARGUMENTS ")"
ARGUMENTS = EXPRESSION{","}

/*
    Арифметическое выражение с операциями: +, -, *, /, %, >, <, >=, <=, ==, !=, ||, &&
    Семантика и приоритеты операций примерно как в Си
*/
BINARY_EXPRESSION = <define-yourself>
/* Идентификатор как в Си */
IDENTIFIER = <define-yourself>
/* Десятичный целочисленный литерал без ведущих нулей */
LITERAL = <define-yourself>
```

### Обозначения:
```
X{Y} – возможно пустой список из X, разделенный Y
(X)* – повторение X ноль или более раз
(X)? – опциональное вхождение X
```

## Семантика
- Должны быть поддержаны однострочные комментарии, как в языке Си (`//`).
- Функции становятся доступны сразу после объявления, причем только внутри блока, где они объявлены.
- Перегрузки функций (с одинаковыми именами) не поддерживаются.
- Функция/переменная, объявленная во вложенном блоке переопределяет более внешнюю декларацию с таким же именем.
- При использовании неопределенной переменной/функции программа должна завершаться с ошибкой.
- В интерпретаторе должна быть определена встроенная функция `println` с произвольным количеством аргументов.
  Аргументы выводятся на новой строке через пробел.
- Если функция завершается без оператора return, считается что возвращаемое значение – 0.
- Все остальное определяется исходя из здравого смысла :)

## Примеры
```
var a = 10
var b = 20
if (a > b) {
    println(1)
} else {
    println(0)
}
```

```
fun fib(n) {
    if (n <= 1) {
        return 1
    }
    return fib(n - 1) + fib(n - 2)
}

var i = 1
while (i <= 5) {
    println(i, fib(i))
    i = i + 1
}
```

```
fun foo(n) {
    fun bar(m) {
        return m + n
    }

    return bar(1)
}

println(foo(41)) // prints 42
```

## Требования к реализации
- Функция `main` должна интерпретировать файл, имя которого передано в первом аргументе.
- Можно использовать генераторы парсеров (см. ветку `antlr-example`).
- Если вы реализуете разбор вручную, то он должен состоять из двух частей: лексер и парсер.
    - Можно использовать генераторы лексеров (например, jflex)
- В случае наличия во входных данных синтаксической ошибки, интерпретатор должен
выдать номер строки, где что-то пошло не так.
- Вместе с решением должны быть предоставлены unit-тесты. Ожидаются три вида отдельных тестов:
    - Парсинг
    - Интерпретация готового дерева
    - Простые на "связку" первых двух компонентов
- По возможности исходный код не должен содержать предупреждений IDE
- Ваше решение должно собираться с помощью Gradle
>>>>>>> 0c38da7296fc1a0bf57d51107c8edcf4e2dd7d8a
